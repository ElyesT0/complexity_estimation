{"mappings":"ACiCA,MAAM,EAAY,CAChB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,CACpC,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,CACpC,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,CACpC,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,CACpC,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,CACpC,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,CACpC,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,CACpC,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,CACpC,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,CACpC,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,CACpC,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,CACpC,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,CACpC,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,CACpC,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,CACpC,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,CACpC,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,CACpC,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,CACpC,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,CACpC,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,CACpC,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,CACpC,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,CACpC,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,CACpC,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,CACpC,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,CACpC,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,CACrC,CAqBkB,eAAe,OAAO,CAAC,gBAgD1C,MAAM,EAAU,SAAU,EAAM,CAAoB,EAGlD,IAAK,IAAI,EAAI,EAAG,EAAI,EAAI,MAAM,CAAE,IAAK,CACnC,IAAI,EAAS,KAAK,KAAK,CAAC,KAAK,MAAM,GAAK,EAAI,MAAM,EAC9C,EAAS,KAAK,KAAK,CAAC,KAAK,MAAM,GAAK,EAAI,MAAM,EAC9C,EAAO,CAAG,CAAC,EAAO,AACtB,CAAA,CAAG,CAAC,EAAO,CAAG,CAAG,CAAC,EAAO,CACzB,CAAG,CAAC,EAAO,CAAG,CAChB,CAEA,OAAO,CACT,EAYM,EAAmB,SAAU,EAAM,CAAS,EAMhD,IAAI,EAAmB,EAAE,CACrB,EAAqB,EAAE,CAE3B,IAAK,IAAI,EAAI,EAAG,EAAI,EAAI,MAAM,CAAE,IAE9B,EAAiB,IAAI,CAAC,IAAI,IAAI,IAAI,CAAG,CAAC,EAAE,EAAE,EAE5C,IAAI,EAAgB,EAAE,CAClB,EAAO,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,CACzB,EAAM,EAAE,CACZ,IAAK,IAAI,EAAI,EAAG,EAAI,EAAI,MAAM,CAAE,IAAK,CAGnC,EADA,EAAO,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,EAEzB,EAAM,EAAE,CACR,IAAK,IAAI,EAAI,EAAG,EAAI,CAAgB,CAAC,EAAE,CAAC,MAAM,CAAE,IAC9C,EAAI,IAAI,CAAC,EAAK,KAAK,IAErB,EAAmB,IAAI,CAAC,GACxB,EAAO,EAAE,CAET,IAAK,IAAI,EAAI,EAAG,EAAI,CAAG,CAAC,EAAE,CAAC,MAAM,CAAE,IAC7B,CAAG,CAAC,EAAE,CAAC,EAAE,EAAI,CAAgB,CAAC,EAAE,CAAC,EAAE,CACrC,EAAK,IAAI,CAAC,CAAkB,CAAC,EAAE,CAAC,EAAE,EACzB,CAAG,CAAC,EAAE,CAAC,EAAE,EAAI,CAAgB,CAAC,EAAE,CAAC,EAAE,CAC5C,EAAK,IAAI,CAAC,CAAkB,CAAC,EAAE,CAAC,EAAE,EACzB,CAAG,CAAC,EAAE,CAAC,EAAE,EAAI,CAAgB,CAAC,EAAE,CAAC,EAAE,CAC5C,EAAK,IAAI,CAAC,CAAkB,CAAC,EAAE,CAAC,EAAE,EACzB,CAAG,CAAC,EAAE,CAAC,EAAE,EAAI,CAAgB,CAAC,EAAE,CAAC,EAAE,CAC5C,EAAK,IAAI,CAAC,CAAkB,CAAC,EAAE,CAAC,EAAE,EACzB,CAAG,CAAC,EAAE,CAAC,EAAE,EAAI,CAAgB,CAAC,EAAE,CAAC,EAAE,CAC5C,EAAK,IAAI,CAAC,CAAkB,CAAC,EAAE,CAAC,EAAE,EAElC,EAAK,IAAI,CAAC,CAAkB,CAAC,EAAE,CAAC,EAAE,EAGtC,EAAc,IAAI,CAAC,EACrB,CACA,OAAO,CACT,EAkU4B,SAAS,cAAc,CAAC,0BAC9B,SAAS,cAAc,CAAC,kBA2H7B,AArfF,WAIb,IAAK,IAAI,EAAI,EAAG,EAAI,GAAI,KAI1B,IAsfA,IAAI,EAAuB,IANK,EADP,EAAQ,OAKA,EADF,EADT,IAAI,EAAU,GAOnC","sources":["<anon>","data_sequences.js"],"sourcesContent":["\"use strict\";\n/* NOTE\n======================================================\n++++++++++++++++ Data of the Sequences +++++++++++++++\n======================================================\n*/ /*\nconst sequences_training = [\n  // only used for the training phase: use to train and calibrate experiment\n  [0, 1, 2, 3, 0, 1, 2, 3],\n  [1, 2, 3, 4, 5, 5, 4, 3, 2, 1],\n];\n*/ const sequences_training = [\n    // only used for the training phase: use to train and calibrate experiment\n    [\n        0,\n        1,\n        2,\n        3,\n        0,\n        1,\n        2,\n        3\n    ],\n    [\n        1,\n        2,\n        3,\n        4,\n        5,\n        5,\n        4,\n        3,\n        2,\n        1\n    ],\n    //PHASE 2 training: learning sequence length\n    [\n        0,\n        1,\n        2,\n        3,\n        4,\n        5,\n        0,\n        1,\n        2,\n        3,\n        4,\n        5\n    ],\n    //PHASE 3 training: learning repetitions\n    [\n        0,\n        1,\n        2,\n        3,\n        3,\n        2,\n        1,\n        0,\n        0,\n        1,\n        2,\n        3\n    ],\n    [\n        0,\n        1,\n        2,\n        2,\n        1,\n        0,\n        0,\n        1,\n        2,\n        2,\n        1,\n        0\n    ]\n];\n/*\nconst sequences = [\n  [0, 1, 0, 1],\n  [1, 2, 3, 1, 2, 3],\n];\n*/ const sequences = [\n    [\n        0,\n        1,\n        0,\n        2,\n        0,\n        3,\n        0,\n        1,\n        0,\n        2,\n        0,\n        3\n    ],\n    [\n        0,\n        1,\n        0,\n        2,\n        1,\n        3,\n        0,\n        1,\n        0,\n        2,\n        1,\n        3\n    ],\n    [\n        0,\n        1,\n        2,\n        3,\n        0,\n        1,\n        2,\n        1,\n        0,\n        1,\n        2,\n        0\n    ],\n    [\n        0,\n        1,\n        2,\n        3,\n        0,\n        2,\n        1,\n        2,\n        0,\n        1,\n        2,\n        0\n    ],\n    [\n        0,\n        1,\n        2,\n        3,\n        0,\n        1,\n        2,\n        4,\n        0,\n        1,\n        2,\n        5\n    ],\n    [\n        0,\n        1,\n        2,\n        3,\n        0,\n        2,\n        1,\n        4,\n        0,\n        1,\n        2,\n        5\n    ],\n    [\n        0,\n        1,\n        0,\n        0,\n        1,\n        1,\n        0,\n        0,\n        0,\n        1,\n        1,\n        1\n    ],\n    [\n        0,\n        0,\n        0,\n        1,\n        1,\n        1,\n        0,\n        1,\n        0,\n        0,\n        1,\n        1\n    ],\n    [\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        2,\n        0,\n        0,\n        0,\n        3\n    ],\n    [\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        2,\n        0,\n        0,\n        0,\n        0,\n        3\n    ],\n    [\n        0,\n        1,\n        2,\n        0,\n        1,\n        2,\n        3,\n        0,\n        1,\n        2,\n        3,\n        4\n    ],\n    [\n        0,\n        1,\n        2,\n        3,\n        4,\n        0,\n        1,\n        2,\n        3,\n        0,\n        1,\n        2\n    ],\n    [\n        0,\n        1,\n        2,\n        3,\n        3,\n        2,\n        1,\n        0,\n        0,\n        1,\n        2,\n        3\n    ],\n    [\n        0,\n        1,\n        2,\n        3,\n        3,\n        1,\n        2,\n        0,\n        0,\n        1,\n        2,\n        3\n    ],\n    [\n        0,\n        1,\n        2,\n        3,\n        2,\n        1,\n        0,\n        3,\n        0,\n        1,\n        2,\n        3\n    ],\n    [\n        0,\n        1,\n        2,\n        3,\n        2,\n        0,\n        1,\n        3,\n        0,\n        1,\n        2,\n        3\n    ],\n    [\n        1,\n        2,\n        1,\n        2,\n        1,\n        2,\n        1,\n        2,\n        1,\n        2,\n        1,\n        2\n    ],\n    [\n        1,\n        2,\n        3,\n        1,\n        2,\n        3,\n        1,\n        2,\n        3,\n        1,\n        2,\n        3\n    ],\n    [\n        1,\n        2,\n        3,\n        4,\n        1,\n        2,\n        3,\n        4,\n        1,\n        2,\n        3,\n        4\n    ],\n    [\n        1,\n        1,\n        2,\n        2,\n        3,\n        3,\n        1,\n        1,\n        2,\n        2,\n        3,\n        3\n    ],\n    [\n        1,\n        2,\n        2,\n        2,\n        2,\n        1,\n        1,\n        2,\n        1,\n        1,\n        1,\n        2\n    ],\n    [\n        1,\n        2,\n        3,\n        1,\n        3,\n        2,\n        2,\n        3,\n        1,\n        2,\n        1,\n        3\n    ],\n    [\n        1,\n        2,\n        3,\n        4,\n        3,\n        2,\n        4,\n        1,\n        1,\n        4,\n        2,\n        3\n    ],\n    [\n        1,\n        2,\n        3,\n        1,\n        3,\n        2,\n        1,\n        2,\n        3,\n        1,\n        3,\n        2\n    ],\n    [\n        1,\n        1,\n        2,\n        2,\n        3,\n        3,\n        1,\n        1,\n        3,\n        3,\n        2,\n        2\n    ]\n];\n/*\nconst sequences = [\n  [1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2], // token:2 ; repetition: 6\n  [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3], // token:3 ; repetition: 4\n  [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4], // token:4 ; repetition: 3\n  [1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3], // token:3 ; repetition: 2levels/nested\n  [1, 2, 2, 2, 2, 1, 1, 2, 1, 1, 1, 2], // token:2 ; repetition: 6; control\n  [1, 2, 3, 1, 3, 2, 2, 3, 1, 2, 1, 3], // token:3 ; repetition: 4; control; no structure\n  [1, 2, 3, 4, 3, 2, 4, 1, 1, 4, 2, 3], // token:4 ; repetition: 3; control\n  [1, 2, 3, 1, 3, 2, 1, 2, 3, 1, 3, 2], // token:3 ; repetition: 2levels/nested; control 1 global repetition but not local\n  [1, 1, 2, 2, 3, 3, 1, 1, 3, 3, 2, 2], // token:3 ; repetition: 2levels/nested; control 2 local repetition but not global\n];\n*/ // const sequences = [[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]];\nvar progress = 0; //Represent the progression of the participant towards the end of the experiment\nvar completion = 0; //Represent the percentage of completion of the experiment\nvar feedbackTXT = \"\";\nvar distanceDL;\nvar lan_selected = sessionStorage.getItem(\"lan_selected\");\nconst nb_repetition = 2; // number of times the series of sequences are presented\nconst blink = 300; //actual visual duration of the stimuli in ms\nconst SOA = 400;\nconst initialScore = 1000; //Starting number of points for the score\nconst keyEvent = \"touchend\"; //touchend or click depending on the device\nconst set_delay = 750; //Short delay before start/end of presentation\nconst break_time = 1500; //Delay between end of presentation and start of reproduction\nconst instruction_training_start_eng = [\n    \"A sequence of points will be presented to you. Try to memorize it.\",\n    \"After a short delay, you'll be asked to reproduce it. Please use your index finger.\",\n    \"Once you are done, push one of the buttons at the bottom of the screen to bet on your guess. The higher your bet, the higher your potential gains or losses!\",\n    \"You have to enter at least 3 points before you are able to bet.\"\n];\nconst instruction_training_end_eng = [\n    \"Congratulation, you were successful in completing the training!\",\n    \"The following game will be more challenging. Even if you do not know, please try to give an answer on each trial.\",\n    \"All your answers and mistakes will give us valuable insight into the human mind.\",\n    \"You will now start the full experiment.\"\n];\nconst instruction_training_start_fr = [\n    \"Une s\\xe9quence de points vous sera pr\\xe9sent\\xe9e. Essayez de la m\\xe9moriser.\",\n    \"Apr\\xe8s un court d\\xe9lai, vous devrez la reproduire. Veuillez utiliser votre index.\",\n    \"Une fois termin\\xe9, appuyez sur l'un des boutons en bas de l'\\xe9cran pour parier sur votre estimation. Plus vous misez, plus vos gains ou pertes potentiels sont \\xe9lev\\xe9s !\",\n    \"Vous devez saisir au moins 3 points avant de pouvoir parier.\"\n];\nconst instruction_training_end_fr = [\n    \"F\\xe9licitations, vous avez r\\xe9ussi \\xe0 terminer l'entra\\xeenement !\",\n    \"Le jeu suivant sera plus difficile. M\\xeame si vous ne savez pas, essayez de donner une r\\xe9ponse \\xe0 chaque essai.\",\n    \"Toutes vos r\\xe9ponses et erreurs nous fourniront des informations pr\\xe9cieuses sur l'esprit humain.\",\n    \"Vous allez maintenant commencer l'exp\\xe9rience compl\\xe8te.\"\n];\nif (lan_selected === \"Fr\") {\n    var instruction_training_start = instruction_training_start_fr;\n    var instruction_training_end = instruction_training_end_fr;\n} else {\n    var instruction_training_start = instruction_training_start_eng;\n    var instruction_training_end = instruction_training_end_eng;\n}\n/* NOTE\n======================================================\n++++++++++++++ Base functions definition +++++++++++++\n======================================================\n*/ const shuffle = function(seq = randomized_sequences) {\n    // purpose: shuffle the sequences by switching positions of the sequences in the array several times\n    for(let i = 0; i < seq.length; i++){\n        let rand_1 = Math.trunc(Math.random() * seq.length);\n        let rand_2 = Math.trunc(Math.random() * seq.length);\n        let temp = seq[rand_1];\n        seq[rand_1] = seq[rand_2];\n        seq[rand_2] = temp;\n    }\n    return seq;\n};\nconst makeId = function() {\n    let participant_ID = \"\";\n    // >purpose: generating a random ID for participant\n    let characters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n    for(var i = 0; i < 12; i++)participant_ID += characters.charAt(Math.floor(Math.random() * 36));\n    return participant_ID;\n};\nconst randomize_points = function(seq = sequences) {\n    // >purpose: randomize spatial positions while saving structure of sequences\n    /* avec cette méthode toutes les séquences doivent être inscrites sous forme\n1,2,3,4... ou 1,2,3... etc. Mais 2,4,5... ne fonctionnent pas.\n*/ var unique_sequences = []; // will contain the unique positions of each sequence\n    var randomized_uniques = []; // will contain the randomized unique positions of each sequence\n    for(let i = 0; i < seq.length; i++)// >purpose: fill the unique_sequences array with unique positions of the sequences array\n    unique_sequences.push([\n        ...new Set(seq[i])\n    ]);\n    let rand_sequence = [];\n    let temp = [\n        0,\n        1,\n        2,\n        3,\n        4,\n        5\n    ];\n    let arr = [];\n    for(let k = 0; k < seq.length; k++){\n        // will be in the big for loop\n        temp = [\n            0,\n            1,\n            2,\n            3,\n            4,\n            5\n        ];\n        shuffle(temp);\n        arr = [];\n        for(let i = 0; i < unique_sequences[k].length; i++)arr.push(temp.shift());\n        randomized_uniques.push(arr);\n        temp = [];\n        for(let i = 0; i < seq[k].length; i++){\n            if (seq[k][i] == unique_sequences[k][0]) temp.push(randomized_uniques[k][0]);\n            else if (seq[k][i] == unique_sequences[k][1]) temp.push(randomized_uniques[k][1]);\n            else if (seq[k][i] == unique_sequences[k][2]) temp.push(randomized_uniques[k][2]);\n            else if (seq[k][i] == unique_sequences[k][3]) temp.push(randomized_uniques[k][3]);\n            else if (seq[k][i] == unique_sequences[k][4]) temp.push(randomized_uniques[k][4]);\n            else temp.push(randomized_uniques[k][5]);\n        }\n        rand_sequence.push(temp);\n    }\n    return rand_sequence;\n};\n/* NOTE\n======================================================\n++++++++++++++ Communication with server +++++++++++++\n======================================================\n*/ function send_post(data) {\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"POST\", \"https://private.unicog.org/manip_meg/code_ext/test_save_data_here/test2.php\", true);\n    xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n    xhr.onload = function() {\n        if (xhr.status === 200 && xhr.responseText !== \"GOT IT\") ;\n        else xhr.status;\n    };\n    xhr.send(encodeURI(\"filedata=\" + data));\n    console.log(\"Data has been sent\");\n}\nfunction convertCSV(obj) {\n    // >purpose: convert a javascript object to a string with a CSV format\n    //variables for the keys\n    let keys = Object.keys(obj);\n    //variables for the values\n    let values = Object.values(obj);\n    let csv = \"\";\n    csv = csv + keys + \"\\n\";\n    for(let i = 0; i < obj.performance.length; i++){\n        for(let k = 0; k < keys.length; k++)// Loop over the number of keys to get all the keys' values one after the other in a line\n        try {\n            //Case 1: the value considered is an array (e.g. original_seq, response_seq_before, interclick_timings_before, ...)\n            if (typeof values[k] === \"object\") csv = csv + '\"' + values[k][i] + '\",';\n            else if (typeof values[k] === \"string\") csv = csv + '\"' + values[k] + '\"' + \",\";\n            else //Case 2: the value considered is a string or a single element (e.g. counter, current_score, SOA...)\n            csv = csv + values[k] + \",\";\n        } catch (error) {\n            csv = csv + '\"\",';\n        }\n        csv = csv + \"\\n\";\n    }\n    return csv;\n}\n/*\nfunction convertCSV(obj, fileName) {\n  // >purpose: convert a javascript object to a string with a CSV format\n\n  //variables for the keys\n  let keys = Object.keys(obj);\n  let temp = [];\n  let txt_keys = '';\n\n  //variables for the values\n  let values = Object.values(obj);\n  let txt_values = '';\n\n  for (let i = 0; i < keys.length; i++) {\n    temp.push(keys[i]);\n  }\n  txt_keys = temp.join(',') + '\\n';\n\n  for (let k = 0; k < obj['seq'].length; k++) {\n    for (let i = 0; i < keys.length; i++) {\n      if (typeof values[i] == 'string') {\n        txt_values += `${values[i]},`;\n      } else if (typeof values[i] == 'number') {\n        txt_values += `${values[i]},`;\n      } else {\n        txt_values += `\"${values[i][k]}\",`;\n      }\n    }\n    txt_values += '\\n';\n  }\n\n  let csv = txt_keys + txt_values;\n  fileName += `${obj.participant_id}`;\n\n  // let csvData = new Blob([csv], { type: \"text/csv\" });\n  // let csvUrl = URL.createObjectURL(csvData);\n\n  // let hiddenElement = document.createElement(\"a\");\n  // hiddenElement.href = csvUrl;\n  // hiddenElement.target = \"_blank\";\n  return csv;\n}\n*/ /* NOTE\n======================================================\n+++++++++++++++ Score and progress bar +++++++++++++++\n======================================================\n*/ function correct_tokens(seqResp, seqRef) {\n    //>purpose: check if all the points answered are in the sequence shown\n    let test_bool = 0; //equal to 1 if at least one of the element isn't in the reference sequence\n    for(let i = 0; i < seqResp.length; i++)if (seqRef.includes(seqResp[i]) == 0) test_bool = 1;\n    return test_bool;\n}\nfunction increase() {\n    // >purpose: make a more dynamic progression update\n    // Change the variable to modify the speed of the number increasing from 0 to (ms)\n    let SPEED = 15;\n    // Retrieve the percentage value\n    let limit = parseInt(document.getElementById(\"value1\").innerHTML, 0);\n    for(let i = 0; i <= limit; i++)setTimeout(function() {\n        document.getElementById(\"value1\").innerHTML = i + \"%\";\n    }, SPEED * i);\n}\nfunction update_progression(percent) {\n    // >purpose: Visually Update the progression Bar\n    document.documentElement.style.setProperty(\"--my-end-width\", `${percent}%`);\n    value1.textContent = `${percent}%`;\n}\nfunction damerauLevenshteinDistance(str1, str2) {\n    const matrix = Array.from({\n        length: str1.length + 1\n    }, ()=>Array(str2.length + 1).fill(0));\n    for(let i = 0; i <= str1.length; i++)matrix[i][0] = i;\n    for(let j = 0; j <= str2.length; j++)matrix[0][j] = j;\n    for(let i = 1; i <= str1.length; i++)for(let j = 1; j <= str2.length; j++){\n        const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;\n        matrix[i][j] = Math.min(matrix[i - 1][j] + 1, matrix[i][j - 1] + 1, matrix[i - 1][j - 1] + cost);\n        if (i > 1 && j > 1 && str1[i - 1] === str2[j - 2] && str1[i - 2] === str2[j - 1]) matrix[i][j] = Math.min(matrix[i][j], matrix[i - 2][j - 2] + cost);\n    }\n    return matrix[str1.length][str2.length];\n}\nfunction score_update(origin_seq, repro_seq, bet, initialScore, txt_score_element) {\n    //>purpose: update the score based on bet and performance in reproduction (damerauLevenshtein distance)\n    /* NOTE: this allows to have a more accurate score update => the more similar the produced\n  sequence to the presented sequence, the more point. Instead of all or none. */ let distDL = damerauLevenshteinDistance(origin_seq, repro_seq); //Damerau-Levenshtein distance\n    //NOTE score must be negative if Damerau-Levenshtein distance ≥5 and positive if <5\n    // score_dl will be in [-1;1]\n    if (distDL >= 5) var score_dl = -distDL / origin_seq.length;\n    else var score_dl = (origin_seq.length - distDL) / origin_seq.length;\n    //compute new score\n    var final_score;\n    if (initialScore === 0) final_score = initialScore;\n    else if (correct_tokens(repro_seq, origin_seq)) final_score = Math.round(-bet) + initialScore;\n    else final_score = Math.round(score_dl * bet) + initialScore;\n    if (final_score < 0) final_score = 0;\n    /* progression bar updating */ progress += 1; //FIXME recent addition, increment the progress, replace with increase\n    completion = Math.floor(100 * progress / (2 * sequences.length));\n    //>purpose: set the variables that will give word and sound feedback to participants\n    if (correct_tokens(repro_seq, origin_seq)) {\n        if (lan_selected == \"Fr\") feedbackTXT = \"Erreur de position\";\n        else feedbackTXT = \"Wrong position\";\n    } else {\n        if (distDL == 0) {\n            if (lan_selected == \"Fr\") feedbackTXT = \"Parfait\";\n            else feedbackTXT = \"Flawless\";\n        } else if (distDL == 1) {\n            if (lan_selected == \"Fr\") feedbackTXT = \"Incroyable!\";\n            else feedbackTXT = \"Genius\";\n        } else if (distDL == 2) {\n            if (lan_selected == \"Fr\") feedbackTXT = \"G\\xe9nial!\";\n            else feedbackTXT = \"Amazing!\";\n        } else if (distDL == 3) {\n            if (lan_selected == \"Fr\") feedbackTXT = \"Tr\\xe8s bien!\";\n            else feedbackTXT = \"Great!\";\n        } else if (distDL == 4) {\n            if (lan_selected == \"Fr\") feedbackTXT = \"Bravo!\";\n            else feedbackTXT = \"Well done\";\n        } else if (distDL == 5) {\n            if (lan_selected == \"Fr\") feedbackTXT = \"Presque\";\n            else feedbackTXT = \"Almost\";\n        } else if (distDL == 6) {\n            if (lan_selected == \"Fr\") feedbackTXT = \"Pas loin\";\n            else feedbackTXT = \"That was close\";\n        } else if (lan_selected == \"Fr\") feedbackTXT = \"Faux\";\n        else feedbackTXT = \"Try again\";\n    }\n    //Adjust position of feedback text so that it is somewhat centered\n    /*\n  if (feedbackTXT.split(' ').length == 1) {\n    txt_score_element.style.transform = `translate(-${\n      50 + feedbackTXT.length * 8\n    }px,-50px)`;\n  } else if (feedbackTXT.split(' ').length == 2) {\n    txt_score_element.style.transform = `translate(-${\n      50 +\n      Math.max(\n        feedbackTXT.split(' ')[0].length,\n        feedbackTXT.split(' ')[1].length\n      ) *\n        8\n    }px,-50px)`;\n  } else if (feedbackTXT.split(' ').length == 3) {\n    txt_score_element.style.transform = `translate(-${\n      50 +\n      Math.max(\n        feedbackTXT.split(' ')[0].length,\n        feedbackTXT.split(' ')[1].length,\n        feedbackTXT.split(' ')[2].length\n      ) *\n        8\n    }px,-50px)`;\n  } else {\n    txt_score_element.style.transform = `translate(-${\n      50 + feedbackTXT.length\n    }px,-50px)`;\n  }*/ return {\n        final_score: final_score,\n        feedbackTXT: feedbackTXT\n    };\n}\n/* NOTE\n======================================================\n+++++++++++++++++++++ Final ranking ++++++++++++++++++\n======================================================\n*/ // DOM manipulation variables\nconst successRate_ranking = document.getElementById(\"success--rate--ranking\");\nconst score_ranking = document.getElementById(\"score--ranking\");\nvar rankValue_score = 0;\n// var rankValue_successRate = 0;\nconst final_rank = function(/*success_rate,*/ finalScore) {\n    //>purpose: compute the rank of the participant compared to previous pilot studies\n    //-----------> According to success rate\n    /* FIXME removed\n  if (success_rate == 1) {\n    rankValue_successRate = 0.0001;\n  } else if (success_rate >= 0.8) {\n    rankValue_successRate = 0.001;\n  } else if (success_rate >= 0.7) {\n    rankValue_successRate = 0.01;\n  } else if (success_rate >= 0.65) {\n    rankValue_successRate = 0.03;\n  } else if (success_rate > 0.6) {\n    rankValue_successRate = 0.05;\n  } else if (success_rate >= 0.55) {\n    rankValue_successRate = 0.1;\n  } else if (success_rate >= 0.5) {\n    rankValue_successRate = 0.2;\n  } else if (success_rate >= 0.4) {\n    rankValue_successRate = 0.3;\n  } else if (success_rate >= 0.35) {\n    rankValue_successRate = 0.4;\n  } else if (success_rate >= 0.3) {\n    rankValue_successRate = 0.5;\n  } else if (success_rate >= 0.25) {\n    rankValue_successRate = 0.6;\n  } else if (success_rate >= 0.2) {\n    rankValue_successRate = 0.7;\n  } else if (success_rate >= 0.15) {\n    rankValue_successRate = 0.8;\n  } else {\n    rankValue_successRate = 0.99;\n  }\n*/ //-----------> According to final score\n    if (finalScore >= 6000) rankValue_score = 0.0001;\n    else if (finalScore >= 4000) rankValue_score = 0.001;\n    else if (finalScore >= 3500) rankValue_score = 0.01;\n    else if (finalScore >= 3300) rankValue_score = 0.03;\n    else if (finalScore > 3000) rankValue_score = 0.05;\n    else if (finalScore >= 2800) rankValue_score = 0.1;\n    else if (finalScore >= 2600) rankValue_score = 0.2;\n    else if (finalScore >= 2500) rankValue_score = 0.3;\n    else if (finalScore >= 2300) rankValue_score = 0.4;\n    else if (finalScore >= 2000) rankValue_score = 0.5;\n    else if (finalScore >= 1800) rankValue_score = 0.6;\n    else if (finalScore >= 1600) rankValue_score = 0.7;\n    else if (finalScore >= 1000) rankValue_score = 0.8;\n    else rankValue_score = 0.99;\n    const low_limit = 0.5; //rate of success under which the feedback message becomes negative\n    if (lan_selected == \"Fr\") {\n        //NOTE FRench\n        /*\n    if (rankValue_successRate > low_limit) {\n      successRate_ranking.textContent = `${Math.trunc(\n        (1 - rankValue_successRate) * 100\n      )}% des plus basses performances.`;\n    } else if (rankValue_successRate < 0.01) {\n      successRate_ranking.textContent = `TOP ${\n        rankValue_successRate * 100\n      }% meilleurs joueurs`;\n    } else {\n      successRate_ranking.textContent = `TOP ${Math.trunc(\n        rankValue_successRate * 100\n      )}% meilleurs joueurs`;\n    }\n    */ if (rankValue_score > low_limit) score_ranking.textContent = `${Math.trunc((1 - rankValue_score) * 100)}% des plus basses performance.`;\n        else if (rankValue_score < 0.01) score_ranking.textContent = `TOP ${rankValue_score * 100}% meilleurs joueurs`;\n        else score_ranking.textContent = `TOP ${Math.trunc(rankValue_score * 100)}% meilleurs joueurs`;\n    } else {\n        //NOTE ENglish\n        if (rankValue_score > low_limit) score_ranking.textContent = `BOTTOM ${Math.trunc((1 - rankValue_score) * 100)}% performance`;\n        else if (rankValue_score < 0.01) score_ranking.textContent = `TOP ${rankValue_score * 100}% best performers`;\n        else score_ranking.textContent = `TOP ${Math.trunc(rankValue_score * 100)}% best performers`;\n    }\n};\n/* NOTE\n======================================================\n+++++++++++++++ Execution of the script ++++++++++++++\n======================================================\n*/ var current_ID = makeId();\nvar shuffled_sequences = shuffle(sequences);\nvar randomized_core_sequences = randomize_points(shuffled_sequences); // Shuffled sequences with random points (see data_sequence for detail on function)\nvar bloc2_sequences = [\n    ...sequences\n]; // Bloc 2 sequences are 2 times the sequences presented in bloc 1\nvar shuffled_bloc2_sequences = shuffle(bloc2_sequences);\nvar randomized_bloc2_sequences = randomize_points(shuffled_bloc2_sequences);\nvar randomized_sequences = [\n    ...randomized_core_sequences,\n    ...randomized_bloc2_sequences\n]; // we put all the randomized sequences in the same array that will be run in the experiment\n\n//# sourceMappingURL=animation_sequence.a42586e9.js.map\n","'use strict';\n\n/* NOTE\n======================================================\n++++++++++++++++ Data of the Sequences +++++++++++++++\n======================================================\n*/\n/*\nconst sequences_training = [\n  // only used for the training phase: use to train and calibrate experiment\n  [0, 1, 2, 3, 0, 1, 2, 3],\n  [1, 2, 3, 4, 5, 5, 4, 3, 2, 1],\n];\n*/\n\nconst sequences_training = [\n  // only used for the training phase: use to train and calibrate experiment\n  [0, 1, 2, 3, 0, 1, 2, 3],\n  [1, 2, 3, 4, 5, 5, 4, 3, 2, 1],\n  //PHASE 2 training: learning sequence length\n  [0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5],\n  //PHASE 3 training: learning repetitions\n  [0, 1, 2, 3, 3, 2, 1, 0, 0, 1, 2, 3],\n  [0, 1, 2, 2, 1, 0, 0, 1, 2, 2, 1, 0],\n];\n\n/*\nconst sequences = [\n  [0, 1, 0, 1],\n  [1, 2, 3, 1, 2, 3],\n];\n*/\n\nconst sequences = [\n  [0, 1, 0, 2, 0, 3, 0, 1, 0, 2, 0, 3], // Play 4 Tokens\n  [0, 1, 0, 2, 1, 3, 0, 1, 0, 2, 1, 3], // Contrôle Play-4 Tokens\n  [0, 1, 2, 3, 0, 1, 2, 1, 0, 1, 2, 0], // Sub-programs 1\n  [0, 1, 2, 3, 0, 2, 1, 2, 0, 1, 2, 0], // Contrôle sub-programs 1\n  [0, 1, 2, 3, 0, 1, 2, 4, 0, 1, 2, 5], // Sub-programs 2\n  [0, 1, 2, 3, 0, 2, 1, 4, 0, 1, 2, 5], // Contrôle sub-programs 2\n  [0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1], // Indice i\n  [0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1], // Contrôle indice i\n  [0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 3], // Play\n  [0, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 3], // Contrôle play\n  [0, 1, 2, 0, 1, 2, 3, 0, 1, 2, 3, 4], // Insertion\n  [0, 1, 2, 3, 4, 0, 1, 2, 3, 0, 1, 2], // Suppression (contrôle insertion)\n  [0, 1, 2, 3, 3, 2, 1, 0, 0, 1, 2, 3], // Miroir 1\n  [0, 1, 2, 3, 3, 1, 2, 0, 0, 1, 2, 3], // Contrôle Miroir 1\n  [0, 1, 2, 3, 2, 1, 0, 3, 0, 1, 2, 3], // Miroir 2\n  [0, 1, 2, 3, 2, 0, 1, 3, 0, 1, 2, 3], // Contrôle Miroir 2\n  [1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2], // token:2 ; repetition: 6\n  [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3], // token:3 ; repetition: 4\n  [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4], // token:4 ; repetition: 3\n  [1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3], // token:3 ; repetition: 2levels/nested\n  [1, 2, 2, 2, 2, 1, 1, 2, 1, 1, 1, 2], // token:2 ; repetition: 6; control\n  [1, 2, 3, 1, 3, 2, 2, 3, 1, 2, 1, 3], // token:3 ; repetition: 4; control; no structure\n  [1, 2, 3, 4, 3, 2, 4, 1, 1, 4, 2, 3], // token:4 ; repetition: 3; control\n  [1, 2, 3, 1, 3, 2, 1, 2, 3, 1, 3, 2], // token:3 ; repetition: 2levels/nested; control 1 global repetition but not local\n  [1, 1, 2, 2, 3, 3, 1, 1, 3, 3, 2, 2], // token:3 ; repetition: 2levels/nested; control 2 local repetition but not global\n];\n\n/*\nconst sequences = [\n  [1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2], // token:2 ; repetition: 6\n  [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3], // token:3 ; repetition: 4\n  [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4], // token:4 ; repetition: 3\n  [1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3], // token:3 ; repetition: 2levels/nested\n  [1, 2, 2, 2, 2, 1, 1, 2, 1, 1, 1, 2], // token:2 ; repetition: 6; control\n  [1, 2, 3, 1, 3, 2, 2, 3, 1, 2, 1, 3], // token:3 ; repetition: 4; control; no structure\n  [1, 2, 3, 4, 3, 2, 4, 1, 1, 4, 2, 3], // token:4 ; repetition: 3; control\n  [1, 2, 3, 1, 3, 2, 1, 2, 3, 1, 3, 2], // token:3 ; repetition: 2levels/nested; control 1 global repetition but not local\n  [1, 1, 2, 2, 3, 3, 1, 1, 3, 3, 2, 2], // token:3 ; repetition: 2levels/nested; control 2 local repetition but not global\n];\n*/\n// const sequences = [[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]];\n\nvar progress = 0; //Represent the progression of the participant towards the end of the experiment\nvar completion = 0; //Represent the percentage of completion of the experiment\nvar feedbackTXT = '';\nvar distanceDL;\nvar lan_selected = sessionStorage.getItem('lan_selected');\nconst nb_repetition = 2; // number of times the series of sequences are presented\nconst blink = 300; //actual visual duration of the stimuli in ms\nconst SOA = 400;\nconst initialScore = 1000; //Starting number of points for the score\nconst keyEvent = 'touchend'; //touchend or click depending on the device\nconst set_delay = 750; //Short delay before start/end of presentation\nconst break_time = 1500; //Delay between end of presentation and start of reproduction\nconst instruction_training_start_eng = [\n  'A sequence of points will be presented to you. Try to memorize it.',\n  \"After a short delay, you'll be asked to reproduce it. Please use your index finger.\",\n  'Once you are done, push one of the buttons at the bottom of the screen to bet on your guess. The higher your bet, the higher your potential gains or losses!',\n  'You have to enter at least 3 points before you are able to bet.',\n];\nconst instruction_training_end_eng = [\n  'Congratulation, you were successful in completing the training!',\n  'The following game will be more challenging. Even if you do not know, please try to give an answer on each trial.',\n  'All your answers and mistakes will give us valuable insight into the human mind.',\n  'You will now start the full experiment.',\n];\n\nconst instruction_training_start_fr = [\n  'Une séquence de points vous sera présentée. Essayez de la mémoriser.',\n  'Après un court délai, vous devrez la reproduire. Veuillez utiliser votre index.',\n  \"Une fois terminé, appuyez sur l'un des boutons en bas de l'écran pour parier sur votre estimation. Plus vous misez, plus vos gains ou pertes potentiels sont élevés !\",\n  'Vous devez saisir au moins 3 points avant de pouvoir parier.',\n];\n\nconst instruction_training_end_fr = [\n  \"Félicitations, vous avez réussi à terminer l'entraînement !\",\n  'Le jeu suivant sera plus difficile. Même si vous ne savez pas, essayez de donner une réponse à chaque essai.',\n  \"Toutes vos réponses et erreurs nous fourniront des informations précieuses sur l'esprit humain.\",\n  \"Vous allez maintenant commencer l'expérience complète.\",\n];\n\nif (lan_selected === 'Fr') {\n  var instruction_training_start = instruction_training_start_fr;\n  var instruction_training_end = instruction_training_end_fr;\n} else {\n  var instruction_training_start = instruction_training_start_eng;\n  var instruction_training_end = instruction_training_end_eng;\n}\n/* NOTE\n======================================================\n++++++++++++++ Base functions definition +++++++++++++\n======================================================\n*/\n\nconst shuffle = function (seq = randomized_sequences) {\n  // purpose: shuffle the sequences by switching positions of the sequences in the array several times\n\n  for (let i = 0; i < seq.length; i++) {\n    let rand_1 = Math.trunc(Math.random() * seq.length);\n    let rand_2 = Math.trunc(Math.random() * seq.length);\n    let temp = seq[rand_1];\n    seq[rand_1] = seq[rand_2];\n    seq[rand_2] = temp;\n  }\n\n  return seq;\n};\n\nconst makeId = function () {\n  let participant_ID = '';\n  // >purpose: generating a random ID for participant\n  let characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n  for (var i = 0; i < 12; i++) {\n    participant_ID += characters.charAt(Math.floor(Math.random() * 36));\n  }\n  return participant_ID;\n};\n\nconst randomize_points = function (seq = sequences) {\n  // >purpose: randomize spatial positions while saving structure of sequences\n\n  /* avec cette méthode toutes les séquences doivent être inscrites sous forme\n1,2,3,4... ou 1,2,3... etc. Mais 2,4,5... ne fonctionnent pas.\n*/\n  var unique_sequences = []; // will contain the unique positions of each sequence\n  var randomized_uniques = []; // will contain the randomized unique positions of each sequence\n\n  for (let i = 0; i < seq.length; i++) {\n    // >purpose: fill the unique_sequences array with unique positions of the sequences array\n    unique_sequences.push([...new Set(seq[i])]);\n  }\n  let rand_sequence = [];\n  let temp = [0, 1, 2, 3, 4, 5];\n  let arr = [];\n  for (let k = 0; k < seq.length; k++) {\n    // will be in the big for loop\n    temp = [0, 1, 2, 3, 4, 5];\n    shuffle(temp);\n    arr = [];\n    for (let i = 0; i < unique_sequences[k].length; i++) {\n      arr.push(temp.shift());\n    }\n    randomized_uniques.push(arr);\n    temp = [];\n\n    for (let i = 0; i < seq[k].length; i++) {\n      if (seq[k][i] == unique_sequences[k][0]) {\n        temp.push(randomized_uniques[k][0]);\n      } else if (seq[k][i] == unique_sequences[k][1]) {\n        temp.push(randomized_uniques[k][1]);\n      } else if (seq[k][i] == unique_sequences[k][2]) {\n        temp.push(randomized_uniques[k][2]);\n      } else if (seq[k][i] == unique_sequences[k][3]) {\n        temp.push(randomized_uniques[k][3]);\n      } else if (seq[k][i] == unique_sequences[k][4]) {\n        temp.push(randomized_uniques[k][4]);\n      } else {\n        temp.push(randomized_uniques[k][5]);\n      }\n    }\n    rand_sequence.push(temp);\n  }\n  return rand_sequence;\n};\n\n/* NOTE\n======================================================\n++++++++++++++ Communication with server +++++++++++++\n======================================================\n*/\n\nfunction send_post(data) {\n  var xhr = new XMLHttpRequest();\n  xhr.open(\n    'POST',\n    'https://private.unicog.org/manip_meg/code_ext/test_save_data_here/test2.php',\n    true\n  );\n  xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n\n  xhr.onload = function () {\n    if (xhr.status === 200 && xhr.responseText !== 'GOT IT') {\n      // document.body.innerHTML += xhr.responseText;\n    } else if (xhr.status !== 200) {\n      // alert('Request failed.  Returned status of ' + xhr.status);\n    }\n  };\n  xhr.send(encodeURI('filedata=' + data));\n  console.log('Data has been sent');\n}\n\nfunction convertCSV(obj) {\n  // >purpose: convert a javascript object to a string with a CSV format\n\n  //variables for the keys\n  let keys = Object.keys(obj);\n\n  //variables for the values\n  let values = Object.values(obj);\n  let csv = '';\n  csv = csv + keys + '\\n';\n  for (let i = 0; i < obj.performance.length; i++) {\n    for (let k = 0; k < keys.length; k++) {\n      // Loop over the number of keys to get all the keys' values one after the other in a line\n      try {\n        //Case 1: the value considered is an array (e.g. original_seq, response_seq_before, interclick_timings_before, ...)\n        if (typeof values[k] === 'object') {\n          csv = csv + '\"' + values[k][i] + '\",';\n        } else if (typeof values[k] === 'string') {\n          csv = csv + '\"' + values[k] + '\"' + ',';\n        } else {\n          //Case 2: the value considered is a string or a single element (e.g. counter, current_score, SOA...)\n\n          csv = csv + values[k] + ',';\n        }\n      } catch (error) {\n        csv = csv + '\"\",';\n      }\n    }\n    csv = csv + '\\n';\n  }\n  return csv;\n}\n\n/*\nfunction convertCSV(obj, fileName) {\n  // >purpose: convert a javascript object to a string with a CSV format\n\n  //variables for the keys\n  let keys = Object.keys(obj);\n  let temp = [];\n  let txt_keys = '';\n\n  //variables for the values\n  let values = Object.values(obj);\n  let txt_values = '';\n\n  for (let i = 0; i < keys.length; i++) {\n    temp.push(keys[i]);\n  }\n  txt_keys = temp.join(',') + '\\n';\n\n  for (let k = 0; k < obj['seq'].length; k++) {\n    for (let i = 0; i < keys.length; i++) {\n      if (typeof values[i] == 'string') {\n        txt_values += `${values[i]},`;\n      } else if (typeof values[i] == 'number') {\n        txt_values += `${values[i]},`;\n      } else {\n        txt_values += `\"${values[i][k]}\",`;\n      }\n    }\n    txt_values += '\\n';\n  }\n\n  let csv = txt_keys + txt_values;\n  fileName += `${obj.participant_id}`;\n\n  // let csvData = new Blob([csv], { type: \"text/csv\" });\n  // let csvUrl = URL.createObjectURL(csvData);\n\n  // let hiddenElement = document.createElement(\"a\");\n  // hiddenElement.href = csvUrl;\n  // hiddenElement.target = \"_blank\";\n  return csv;\n}\n*/\n\n/* NOTE\n======================================================\n+++++++++++++++ Score and progress bar +++++++++++++++\n======================================================\n*/\n\nfunction correct_tokens(seqResp, seqRef) {\n  //>purpose: check if all the points answered are in the sequence shown\n  let test_bool = 0; //equal to 1 if at least one of the element isn't in the reference sequence\n  for (let i = 0; i < seqResp.length; i++) {\n    if (seqRef.includes(seqResp[i]) == 0) {\n      test_bool = 1;\n    }\n  }\n  return test_bool;\n}\n\nfunction increase() {\n  // >purpose: make a more dynamic progression update\n  // Change the variable to modify the speed of the number increasing from 0 to (ms)\n  let SPEED = 15;\n  // Retrieve the percentage value\n  let limit = parseInt(document.getElementById('value1').innerHTML, 0);\n\n  for (let i = 0; i <= limit; i++) {\n    setTimeout(function () {\n      document.getElementById('value1').innerHTML = i + '%';\n    }, SPEED * i);\n  }\n}\n\nfunction update_progression(percent) {\n  // >purpose: Visually Update the progression Bar\n  document.documentElement.style.setProperty('--my-end-width', `${percent}%`);\n  value1.textContent = `${percent}%`;\n}\n\nfunction damerauLevenshteinDistance(str1, str2) {\n  const matrix = Array.from({ length: str1.length + 1 }, () =>\n    Array(str2.length + 1).fill(0)\n  );\n\n  for (let i = 0; i <= str1.length; i++) {\n    matrix[i][0] = i;\n  }\n\n  for (let j = 0; j <= str2.length; j++) {\n    matrix[0][j] = j;\n  }\n\n  for (let i = 1; i <= str1.length; i++) {\n    for (let j = 1; j <= str2.length; j++) {\n      const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;\n\n      matrix[i][j] = Math.min(\n        matrix[i - 1][j] + 1,\n        matrix[i][j - 1] + 1,\n        matrix[i - 1][j - 1] + cost\n      );\n\n      if (\n        i > 1 &&\n        j > 1 &&\n        str1[i - 1] === str2[j - 2] &&\n        str1[i - 2] === str2[j - 1]\n      ) {\n        matrix[i][j] = Math.min(matrix[i][j], matrix[i - 2][j - 2] + cost);\n      }\n    }\n  }\n\n  return matrix[str1.length][str2.length];\n}\n\nfunction score_update(\n  origin_seq,\n  repro_seq,\n  bet,\n  initialScore,\n  txt_score_element\n) {\n  //>purpose: update the score based on bet and performance in reproduction (damerauLevenshtein distance)\n  /* NOTE: this allows to have a more accurate score update => the more similar the produced\n  sequence to the presented sequence, the more point. Instead of all or none. */\n\n  let distDL = damerauLevenshteinDistance(origin_seq, repro_seq); //Damerau-Levenshtein distance\n  //NOTE score must be negative if Damerau-Levenshtein distance ≥5 and positive if <5\n  // score_dl will be in [-1;1]\n\n  if (distDL >= 5) {\n    var score_dl = -distDL / origin_seq.length;\n  } else {\n    var score_dl = (origin_seq.length - distDL) / origin_seq.length;\n  }\n\n  //compute new score\n  var final_score;\n  if (initialScore === 0) {\n    final_score = initialScore;\n    //Do nothing we don't want negative scores\n  } else {\n    if (correct_tokens(repro_seq, origin_seq)) {\n      final_score = Math.round(-bet) + initialScore;\n    } else {\n      final_score = Math.round(score_dl * bet) + initialScore;\n    }\n  }\n\n  if (final_score < 0) {\n    final_score = 0;\n  } else {\n    //do nothing\n  }\n\n  /* progression bar updating */\n  progress += 1; //FIXME recent addition, increment the progress, replace with increase\n  completion = Math.floor((100 * progress) / (2 * sequences.length));\n\n  //>purpose: set the variables that will give word and sound feedback to participants\n  if (correct_tokens(repro_seq, origin_seq)) {\n    if (lan_selected == 'Fr') {\n      feedbackTXT = 'Erreur de position';\n    } else {\n      feedbackTXT = 'Wrong position';\n    }\n  } else {\n    if (distDL == 0) {\n      if (lan_selected == 'Fr') {\n        feedbackTXT = 'Parfait';\n      } else {\n        feedbackTXT = 'Flawless';\n      }\n    } else if (distDL == 1) {\n      if (lan_selected == 'Fr') {\n        feedbackTXT = 'Incroyable!';\n      } else {\n        feedbackTXT = 'Genius';\n      }\n    } else if (distDL == 2) {\n      if (lan_selected == 'Fr') {\n        feedbackTXT = 'Génial!';\n      } else {\n        feedbackTXT = 'Amazing!';\n      }\n    } else if (distDL == 3) {\n      if (lan_selected == 'Fr') {\n        feedbackTXT = 'Très bien!';\n      } else {\n        feedbackTXT = 'Great!';\n      }\n    } else if (distDL == 4) {\n      if (lan_selected == 'Fr') {\n        feedbackTXT = 'Bravo!';\n      } else {\n        feedbackTXT = 'Well done';\n      }\n    } else if (distDL == 5) {\n      if (lan_selected == 'Fr') {\n        feedbackTXT = 'Presque';\n      } else {\n        feedbackTXT = 'Almost';\n      }\n    } else if (distDL == 6) {\n      if (lan_selected == 'Fr') {\n        feedbackTXT = 'Pas loin';\n      } else {\n        feedbackTXT = 'That was close';\n      }\n    } else {\n      if (lan_selected == 'Fr') {\n        feedbackTXT = 'Faux';\n      } else {\n        feedbackTXT = 'Try again';\n      }\n    }\n  }\n\n  //Adjust position of feedback text so that it is somewhat centered\n  /*\n  if (feedbackTXT.split(' ').length == 1) {\n    txt_score_element.style.transform = `translate(-${\n      50 + feedbackTXT.length * 8\n    }px,-50px)`;\n  } else if (feedbackTXT.split(' ').length == 2) {\n    txt_score_element.style.transform = `translate(-${\n      50 +\n      Math.max(\n        feedbackTXT.split(' ')[0].length,\n        feedbackTXT.split(' ')[1].length\n      ) *\n        8\n    }px,-50px)`;\n  } else if (feedbackTXT.split(' ').length == 3) {\n    txt_score_element.style.transform = `translate(-${\n      50 +\n      Math.max(\n        feedbackTXT.split(' ')[0].length,\n        feedbackTXT.split(' ')[1].length,\n        feedbackTXT.split(' ')[2].length\n      ) *\n        8\n    }px,-50px)`;\n  } else {\n    txt_score_element.style.transform = `translate(-${\n      50 + feedbackTXT.length\n    }px,-50px)`;\n  }*/\n\n  return { final_score: final_score, feedbackTXT: feedbackTXT };\n}\n\n/* NOTE\n======================================================\n+++++++++++++++++++++ Final ranking ++++++++++++++++++\n======================================================\n*/\n// DOM manipulation variables\nconst successRate_ranking = document.getElementById('success--rate--ranking');\nconst score_ranking = document.getElementById('score--ranking');\nvar rankValue_score = 0;\n// var rankValue_successRate = 0;\n\nconst final_rank = function (/*success_rate,*/ finalScore) {\n  //>purpose: compute the rank of the participant compared to previous pilot studies\n  //-----------> According to success rate\n  /* FIXME removed\n  if (success_rate == 1) {\n    rankValue_successRate = 0.0001;\n  } else if (success_rate >= 0.8) {\n    rankValue_successRate = 0.001;\n  } else if (success_rate >= 0.7) {\n    rankValue_successRate = 0.01;\n  } else if (success_rate >= 0.65) {\n    rankValue_successRate = 0.03;\n  } else if (success_rate > 0.6) {\n    rankValue_successRate = 0.05;\n  } else if (success_rate >= 0.55) {\n    rankValue_successRate = 0.1;\n  } else if (success_rate >= 0.5) {\n    rankValue_successRate = 0.2;\n  } else if (success_rate >= 0.4) {\n    rankValue_successRate = 0.3;\n  } else if (success_rate >= 0.35) {\n    rankValue_successRate = 0.4;\n  } else if (success_rate >= 0.3) {\n    rankValue_successRate = 0.5;\n  } else if (success_rate >= 0.25) {\n    rankValue_successRate = 0.6;\n  } else if (success_rate >= 0.2) {\n    rankValue_successRate = 0.7;\n  } else if (success_rate >= 0.15) {\n    rankValue_successRate = 0.8;\n  } else {\n    rankValue_successRate = 0.99;\n  }\n*/\n  //-----------> According to final score\n  if (finalScore >= 6000) {\n    rankValue_score = 0.0001;\n  } else if (finalScore >= 4000) {\n    rankValue_score = 0.001;\n  } else if (finalScore >= 3500) {\n    rankValue_score = 0.01;\n  } else if (finalScore >= 3300) {\n    rankValue_score = 0.03;\n  } else if (finalScore > 3000) {\n    rankValue_score = 0.05;\n  } else if (finalScore >= 2800) {\n    rankValue_score = 0.1;\n  } else if (finalScore >= 2600) {\n    rankValue_score = 0.2;\n  } else if (finalScore >= 2500) {\n    rankValue_score = 0.3;\n  } else if (finalScore >= 2300) {\n    rankValue_score = 0.4;\n  } else if (finalScore >= 2000) {\n    rankValue_score = 0.5;\n  } else if (finalScore >= 1800) {\n    rankValue_score = 0.6;\n  } else if (finalScore >= 1600) {\n    rankValue_score = 0.7;\n  } else if (finalScore >= 1000) {\n    rankValue_score = 0.8;\n  } else {\n    rankValue_score = 0.99;\n  }\n  const low_limit = 0.5; //rate of success under which the feedback message becomes negative\n  if (lan_selected == 'Fr') {\n    //NOTE FRench\n    /*\n    if (rankValue_successRate > low_limit) {\n      successRate_ranking.textContent = `${Math.trunc(\n        (1 - rankValue_successRate) * 100\n      )}% des plus basses performances.`;\n    } else if (rankValue_successRate < 0.01) {\n      successRate_ranking.textContent = `TOP ${\n        rankValue_successRate * 100\n      }% meilleurs joueurs`;\n    } else {\n      successRate_ranking.textContent = `TOP ${Math.trunc(\n        rankValue_successRate * 100\n      )}% meilleurs joueurs`;\n    }\n    */\n    if (rankValue_score > low_limit) {\n      score_ranking.textContent = `${Math.trunc(\n        (1 - rankValue_score) * 100\n      )}% des plus basses performance.`;\n    } else if (rankValue_score < 0.01) {\n      score_ranking.textContent = `TOP ${\n        rankValue_score * 100\n      }% meilleurs joueurs`;\n    } else {\n      score_ranking.textContent = `TOP ${Math.trunc(\n        rankValue_score * 100\n      )}% meilleurs joueurs`;\n    }\n  } else {\n    //NOTE ENglish\n    if (rankValue_score > low_limit) {\n      score_ranking.textContent = `BOTTOM ${Math.trunc(\n        (1 - rankValue_score) * 100\n      )}% performance`;\n    } else if (rankValue_score < 0.01) {\n      score_ranking.textContent = `TOP ${\n        rankValue_score * 100\n      }% best performers`;\n    } else {\n      score_ranking.textContent = `TOP ${Math.trunc(\n        rankValue_score * 100\n      )}% best performers`;\n    }\n  }\n};\n\n/* NOTE\n======================================================\n+++++++++++++++ Execution of the script ++++++++++++++\n======================================================\n*/\n\nvar current_ID = makeId();\n\nvar shuffled_sequences = shuffle(sequences);\nvar randomized_core_sequences = randomize_points(shuffled_sequences); // Shuffled sequences with random points (see data_sequence for detail on function)\n\nvar bloc2_sequences = [...sequences]; // Bloc 2 sequences are 2 times the sequences presented in bloc 1\nvar shuffled_bloc2_sequences = shuffle(bloc2_sequences);\nvar randomized_bloc2_sequences = randomize_points(shuffled_bloc2_sequences);\n\nvar randomized_sequences = [\n  ...randomized_core_sequences,\n  ...randomized_bloc2_sequences,\n]; // we put all the randomized sequences in the same array that will be run in the experiment\n"],"names":["sequences","sessionStorage","getItem","shuffle","seq","randomized_sequences","i","length","rand_1","Math","trunc","random","rand_2","temp","randomize_points","unique_sequences","randomized_uniques","push","Set","rand_sequence","arr","k","shift","document","getElementById","makeId"],"version":3,"file":"animation_sequence.a42586e9.js.map"}